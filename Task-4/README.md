Overview: This project implements a focused keypress logger in Python with a strong emphasis on transparency and ethics. The application captures keystrokes only while its window is focused and the user is actively interacting with the program, writes readable, timestamped entries to a local file, and provides a simple graphical interface for starting, stopping, viewing, flushing, saving, and clearing logs. The design prioritizes explicit user consent and visibility of recording activity so the tool remains strictly educational and suitable for legitimate use cases such as accessibility testing, typing analysis within a controlled environment, or debugging input handling.

What I learned: I deepened my understanding of event-driven programming by handling keyboard events and transforming low-level key events into human-friendly log entries. I practiced designing buffered logging systems and learned how to safely append and flush data to disk, balancing performance and durability. I gained practical experience with threading to perform periodic background tasks without blocking the user interface, which improved responsiveness and user experience. Structuring the app with clear start/stop controls and visual feedback reinforced good UX principles and taught me to anticipate user flows and error states.

Technical highlights: I implemented a tkinter GUI that cleanly exposes controls and an on-screen buffer so the user always sees what will be recorded. Keystrokes are captured only when the application window has focus, converted to printable text when possible, and prefixed with high-resolution timestamps for accurate sequencing. The logger buffers entries in memory and periodically flushes them to a timestamped file, with explicit flush on stop or exit to avoid data loss. I also added file save/export functionality and robust exception handling around file I/O to notify users of any write errors. Using a background daemon thread for periodic flushing ensured the main loop stayed responsive to user actions.

Ethical and design considerations: A major lesson from this task is that tools that capture input carry serious privacy and legal responsibilities. Designing the logger to operate only while focused, to show live content on-screen, and to require explicit user actions to start/stop recording keeps the tool ethical and transparent. Building in confirmations for destructive actions and clear prompts for saving or clearing logs reinforced the principle that software should default to protecting user data. These constraints transformed the project from a potentially harmful utility into a learning-focused, consent-driven tool.

How to run and test: Clone or download the repository, open the project folder, and run the focused keypress logger script with a Python 3 interpreter. Focus the application window and use the provided Start/Stop controls while typing; observe the live buffer and verify that entries appear with timestamps. Test file saving and periodic flush behavior and confirm that the log file contains the expected, readable entries. These manual tests validate both the UI interactions and the buffered file-write logic.

Future improvements: Next steps I plan to explore include optional log encryption with a user-provided passphrase, richer export formats (CSV or JSON) for easier analysis, configurable flush intervals and retention policies, support for accessibility metrics such as words-per-minute and error rates, and unit tests for core parsing and buffering logic. Each enhancement will be evaluated through the lens of consent and privacy so the tool remains safe for educational use.
